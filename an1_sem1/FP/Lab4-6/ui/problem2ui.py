from domain.participantslist import ParticipantsList
from ui.table_printer import TableColumn, TablePrinter
from domain.undo_manager import UndoManager
from ui.user_interface import UserInterface, Option

class Problem2UI(UserInterface):

    def add_new_score_args(self,args):
        """
        adds new participant with scores generated by command args
        :param args: list of found args
        """
        self.add_new_score(" ".join(list(map(str,args))))

    def remove_part_args(self,args):
        try:
            self.undo_mng.push_state(self.plist.clone())
            index = int(args[0])
            self.plist.remove(index)
        except Exception as e:
            self.undo_mng.pop_state()
            print("Input data not valid.")
            print(e)

    def add_new_score(self, in_scores = None, register_undo=True):
        """
        Operation to add new participant by score
        :param in_scores: [debug purposes] skip input
        :param register_undo: [debug purposes] true if add to ando list
        """
        try:
            if register_undo:
                self.undo_mng.push_state(self.plist.clone())
            if in_scores==None:
                scores=tuple(map(int,input("The 10 scores separated by spaces : ").split()))
            else:
                scores = tuple(map(int,in_scores.split()))
            new_part = self.plist.add_participant_by_score(scores)
        except Exception as e:
            if register_undo:
                self.undo_mng.pop_state()
            print("Input data incorrect.")
            print(e)
        else:
            if in_scores==None:
                print(f"Added participant with code {new_part.get_code()} at index {new_part.get_index()}")

    def insert_score(self):
        """
        operation to insert new score
        """
        try:
            self.undo_mng.push_state(self.plist.clone())
            code = int(input("Give participant's code:"))
            scores = tuple(map(int, input("The 10 scores separated by spaces : ").split()))
            new_part = self.plist.insert_participant(code,scores)
        except Exception as e:
            self.undo_mng.pop_state()
            print("Input data incorrect.")
            print(e)
        else:
            print(f"Added participant with code {new_part.get_code()} at index {new_part.get_index()}")

    def print_scores_less_than_args(self, args):
        try:
            score = args[0]
            print(score)
            if score<1 or score>100:
                raise ValueError()
        except:
            score = 100
        finally:
            self.plist.print(self.table_printer, lambda p:p.overall_score()<=score)

    def print_scores_less_than(self):
        """
        operation print scores less than a value
        :return:
        """
        try:
            score = int(input("Give maximum score : "))
            if score<1 or score>100:
                raise ValueError()
        except:
            score = 100
        finally:
            self.plist.print(self.table_printer, lambda p:p.overall_score()<=score)

    def print_ordered_by_score(self):
        """
        operation print ordered by scores
        """
        self.plist.print(self.table_printer, sortKey=lambda p:p.overall_score(),sortReversed=True)

    def print_scores_higher(self):
        """
        operation print scores higher than a value ordered by score
        """
        try:
            score = int(input("Give minimum score : "))
            if score<1 or score>100:
                raise ValueError()
        except:
            score = 0
        finally:
            self.plist.print(self.table_printer, lambda p:p.overall_score()>=score,lambda p:p.overall_score(),True)

    def print_mul_x(self):
        """
        operation print scores multiple of a value
        """
        try:
            factor = int(input("Give factor : "))
            if factor<1 or factor>100:
                raise ValueError()
        except:
            factor = 1
        finally:
            self.plist.print(self.table_printer,lambda p:p.overall_score()%factor==0)

    def get_average_args(self, args):
        if self.plist.count() == 0:
            print("Insufficient data. Please add some participants.")
            return
        try:
            avg = self.plist.average(args[0], args[1])
            self.plist.average(args[0], args[1])  # blindly test for eventual errors
        except:
            interval = (1, self.plist.count())

        avg = self.plist.average(args[0], args[1])
        print(f"The average score for interval [{args[0]},{args[1]}] is {avg}")

    def get_average(self):
        """
        operation print average of interval scores
        """
        if self.plist.count()==0:
            print("Insufficient data. Please add some participants.")
            return
        try:
            interval = tuple(map(int,input("Give the interval bounds separated by space : ").split()))
            if len(interval)!=2:
                raise ValueError
            avg = self.plist.average(interval[0],interval[1])
            self.plist.average(interval[0], interval[1])  # blindly test for eventual errors
        except:
            interval = (1,self.plist.count())

        avg = self.plist.average(interval[0], interval[1])
        print(f"The average score for interval [{interval[0]},{interval[1]}] is {avg}")

    def get_min(self):
        """
        operation print min of interval scores
        """
        if self.plist.count() == 0:
            print("Insufficient data. Please add some participants.")
            return
        try:
            interval = tuple(map(int, input("Give the interval bounds separated by space : ").split()))
            if len(interval) != 2:
                raise ValueError
            self.plist.min(interval[0], interval[1]) # blindly test for eventual errors
        except:
            interval = (1, self.plist.count())

        smin = self.plist.min(interval[0], interval[1])
        print(f"The minimum score for interval [{interval[0]},{interval[1]}] is {smin}")

    def filter_mul_x(self):
        """
        operation filter scores multiple of a value
        """
        try:
            self.undo_mng.push_state(self.plist.clone())
            factor = int(input("Give factor : "))
            if factor < 1 or factor > 100:
                raise ValueError()
        except:
            factor = 1
        finally:
            old_count=self.plist.count()
            self.plist.filter(lambda p:p.overall_score()%factor==0)
            new_count = self.plist.count()
            print(f"Filtered {new_count} participants out of {old_count}.")

    def filter_scores_less_than(self):
        """
        operation filter scores less than a value
        """
        try:
            self.undo_mng.push_state(self.plist.clone())
            score = int(input("Give maximum score : "))
            if score<1 or score>100:
                raise ValueError()
        except:
            score = 100
        finally:
            old_count = self.plist.count()
            self.plist.filter(lambda p:p.overall_score()<=score)
            new_count = self.plist.count()
            print(f"Filtered {new_count} participants out of {old_count}.")

    def load_file(self):
        """
        [debug only]
        load predefined list of participants
        """
        self.undo_mng.push_state(self.plist.clone())
        lines = open('dummy_data.txt','r').readlines()
        for line in lines:
            self.add_new_score(line, register_undo=False)

    def remove_part(self):
        """
        operation remove participant
        """
        try:
            self.undo_mng.push_state(self.plist.clone())
            index = int(input("Give target index : "))
            self.plist.remove(index)
        except Exception as e:
            self.undo_mng.pop_state()
            print("Input data not valid.")
            print(e)

    def remove_range(self):
        """
        operation remove interval of participants
        """
        try:
            self.undo_mng.push_state(self.plist.clone())
            interval = tuple(map(int,input("Give the interval bounds separated by space : ").split()))
            if len(interval)!=2:
                raise ValueError
            self.plist.remove_range(interval[0],interval[1])
        except Exception as e:
            self.undo_mng.pop_state()
            print("Input data not valid.")
            print(e)

    def undo(self):
        """
        operation undo last operation
        """
        del self.plist
        try:
            self.plist = self.undo_mng.pop_state()
        except IndexError as e:
            print(e)

    def change_score(self):
        try:
            self.undo_mng.push_state(self.plist.clone())
            code = int(input("Give participant's code:"))
            part = self.plist.get_participant_by_code(code)
            print("To change all the scores, type a new score (1-10) for each of the ten problems, separated by space.")
            print("To change a single problem score, type the problem's number and the new score.")
            scores = tuple(map(int, input(">> ").split()))
            if len(scores)==10:
                part.set_scores(scores)
            elif len(scores)==2:
                part.change_score(scores[0],scores[1])
            else:
                raise ValueError("Either 2 or 10 values are requested")
        except Exception as e:
            self.undo_mng.pop_state()
            print("Input data incorrect.")
            print(e)
        else:
            pass

    def print_commands(self):
        for option in self.options:
            if option.com_args is not None:
                print(" ".join(option.com_args))

    def __init__(self):
        UserInterface.__init__(self)
        self.plist = ParticipantsList()
        self.undo_mng = UndoManager(50)

        self.options = [
            Option("9", "Show command help menu", self.print_commands),
            Option("0", "Load participants list from file (DEBUG ONLY)", self.load_file),

            Option("1", "Add participant", None),
            Option("1a", "Add new participant by scores", self.add_new_score,
                   "Add new participant with scores %i %i %i %i %i %i %i %i %i %i",
                   self.add_new_score_args),
            Option("1b", "Insert participant by code and score", self.insert_score),

            Option("2", "Remove participant", None),
            Option("2a", "Remove participant by index", self.remove_part,
                   "Remove participant at index %i",
                   self.remove_part_args),
            Option("2b", "Remove interval of participants by index", self.remove_range),
            Option("2c", "Change participant's score", self.change_score),

            Option("3", "Print list of participants", None),
            Option("3a", "Print list of participants with score less than a given value (default : <=100)",
                   self.print_scores_less_than,
                   "Print participants with score less than %i",
                   self.print_scores_less_than_args),
            Option("3b", "Print list of participants ordered by score ", self.print_ordered_by_score),
            Option("3c", "Print list of participants with score higher than a given value (default : >=0)",
                   self.print_scores_higher),

            Option("4", "Operations on subset of participants", None),
            Option("4a", "Find average score for an interval of paricipants by index (default: entire list)",
                   self.get_average,
                   "Find average of participants %i - %i",
                   self.get_average_args),
            Option("4b", "Find minimum score for an interval of paricipants by index (default: entire list)",
                   self.get_min),
            Option("4c", "Print list of participants with score multiple of a given value (default: 1)",
                   self.print_mul_x),

            Option("5", "Filter participants", None),
            Option("5a", "Filter participants with score multiple of a given value (default:1)",
                   self.filter_mul_x),
            Option("5b", "Filter participants with score less then a given value (default:100)",
                   self.filter_scores_less_than),
            Option("6", "Undo the last operation", self.undo),
            Option("7", "Exit", exit)
        ]

        self.table_printer = TablePrinter()
        # init table printer
        self.table_printer.columnsData.append(TableColumn("Crt.", lambda x: x.get_index()))
        self.table_printer.columnsData.append(TableColumn("Code", lambda x: x.get_code()))
        # for i in range(10):
        # lambda x: x.scores[i] is the same function for all i (why?????????)
        self.table_printer.columnsData.append((TableColumn("P" + str(1), lambda x: x.get_scores()[0])))
        self.table_printer.columnsData.append((TableColumn("P" + str(2), lambda x: x.get_scores()[1])))
        self.table_printer.columnsData.append((TableColumn("P" + str(3), lambda x: x.get_scores()[2])))
        self.table_printer.columnsData.append((TableColumn("P" + str(4), lambda x: x.get_scores()[3])))
        self.table_printer.columnsData.append((TableColumn("P" + str(5), lambda x: x.get_scores()[4])))
        self.table_printer.columnsData.append((TableColumn("P" + str(6), lambda x: x.get_scores()[5])))
        self.table_printer.columnsData.append((TableColumn("P" + str(7), lambda x: x.get_scores()[6])))
        self.table_printer.columnsData.append((TableColumn("P" + str(8), lambda x: x.get_scores()[7])))
        self.table_printer.columnsData.append((TableColumn("P" + str(8), lambda x: x.get_scores()[8])))
        self.table_printer.columnsData.append((TableColumn("P" + str(10), lambda x: x.get_scores()[9])))
        self.table_printer.columnsData.append(TableColumn("Score", lambda x: x.overall_score()))
